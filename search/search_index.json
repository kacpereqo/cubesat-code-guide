{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wielka ksi\u0119ga przewinie\u0144 programist\u00f3w osadzonych NASA Google ISO C++ SAT Wst\u0119p Jak wiadomo, dokumentacji nikt nie b\u0119dzie czyta\u0142 dok\u0142adnie, s\u0142owo w s\u0142owo. Wi\u0119c prosz\u0119 si\u0119 nie zdziwi\u0107 jak pojawi\u0105 si\u0119 tutaj jajka wielkanocno \u015bwi\u0105teczne, a forma nie b\u0119dzie w pe\u0142ni oficjalna. Ka\u017cdy punkt b\u0119dzie wygl\u0105da\u0142 na zasadzie Rozwi\u0105zanie -> Problemy tego rozwi\u0105zania -> Lepsze rozwi\u0105zanie + potencjalne wyj\u0105tki B\u0119dzie u\u017cywany C++20, skoro robimy co\u015b mega, to b\u0119dzie nowocze\u015bnie. Za\u0142o\u017cenia Projekt tworzenia studenckiego satelity, nie jest projektem drogiej todo listy. Programi\u015bci, przychodz\u0105, odchodz\u0105, stale... Programi\u015bci w projekcie b\u0119da si\u0119 przewija\u0107, b\u0119da z r\u00f3\u017cnym do\u015bwiadczeniem, z r\u00f3\u017cn\u0105 wiedz\u0105. To jest pow\u00f3d dla kt\u00f3rego kod powinien by\u0107 jak najprostszy, to znaczy, bez fiku\u015bnych twor\u00f3w np std::views , z du\u017c\u0105 ilo\u015bci\u0105 dokumentacji. W takim wypadku wdro\u017cenie nowej osoby do projektu powinno te\u017c przebiega\u0107 szybko. Programi\u015bci b\u0119da przychodzi\u0107 z innych j\u0119zyk\u00f3w. todo proces wdra\u017cania nowych ludzi do projektu Setup Projektu Flagi kompilatora Kompilator powinen krzycze\u0107 na wszystkie erorry i warningi wszystko na czerwono taka litania -Wall -Wextra -Wpedantic -Werror -Wconversion -Wshadow -Wstrict-overflow=5 -Wfloat-equal -Wformat=2 \\ -Wundef -Wpointer-arith -Wcast-qual -Wcast-align=strict -Wstrict-prototypes -Wwrite-strings -Wstack-protector \\ -Wswitch-enum -Wswitch-default -Wunreachable-code -Wduplicated-cond -Wduplicated-branches -Wlogical-op \\ -Wnull-dereference -Wuseless-cast -Wdouble-promotion -Walloca -Walloc-zero -Wvla -Wformat-signedness \\ -Wstrict-aliasing=3 -Wdisabled-optimization -Wunsafe-loop-optimizations -Wvector-operation-performance \\ -Wpessimizing-move -Wredundant-move -Wmisleading-indentation -Wvolatile-register-var -Wdate-time todo jak wszystko b\u0119dzie gotowe to jaki\u015b filmik co\u015b ten powstanie Filozofia pisania kodu Wydajno\u015b\u0107 Wydajno\u015b\u0107 nie jest najwa\u017cniejsza, ale nie jest pomijalna. Wydajno\u015b\u0107 kodu bezpo\u015brednio przek\u0142ada si\u0119 m.in na zu\u017cycie energii przez satelit\u0119. Piszemy kod zgodny ze standardami ISO, wolnym od UB i zale\u017cnym od kompilatora 1. Czytanie Kodu. Kod b\u0119dzie czytany wi\u0119cej razy, ni\u017c b\u0119dzie pisany, dlatego czytelno\u015b\u0107 powinna by\u0107 zawsze priorytetem. Dobrze napisany kod to taki, kt\u00f3ry mo\u017cna \u0142atwo zrozumie\u0107 bez konieczno\u015bci g\u0142\u0119bokiej analizy. Przejrzysty kod u\u0142atwia jego utrzymanie, modyfikacj\u0119 oraz wsp\u00f3\u0142prac\u0119 w zespole. 2. Kod ma wyra\u017ca\u0107 intencje. Pierwszym punktem \u017ceby uczyni\u0107 kod czytelniejszym, programista ma przekazywa\u0107 swoje intencje w kodzie, przez nazewnictwo, dob\u00f3r algorytm\u00f3w i struktur danych. Spos\u00f3b pisania kodu powinien by\u0107 jak najbardziej przewidywalny dla innych. \u274cFunkcja c nie m\u00f3wi nic o swojej intencji \u2013 nazwa jest nieczytelna. Parametry a i b nic nie wyja\u015bniaj\u0105. int A(int a, int b) { return a * b; } \u2705Funkcja ma teraz nazw\u0119 calculateArea, co jasno okre\u015bla jej cel. Parametry width i height m\u00f3wi\u0105, do czego s\u0142u\u017c\u0105. int calculateArea(int width, int height) { return width * height; } 3. Type safety first Zgodno\u015b\u0107 typ\u00f3w jest jednym z najpot\u0119\u017cniejszych narz\u0119dzi walki z robakami (en. bug) w kodzie \u274c void print_arr(void* arr, size_t len){ for(int i = 0; i < len; i++) std::cout << arr[i]; } \u2705 ```cpp template <typename T> void print_arr(std::span<T> arr){ for(const auto& item : arr) std::cout << item; } [?] Typy do reprezentacji jednostek SI 4. Wybieraj wykonanie w compile time zamiast run time Pow\u00f3d Je\u017celi jeste\u015b w stanie zrobi\u0107 co\u015b w compile to tym zwi\u0119kszysz performance kodu. Przyk\u0142ad \u274c Funkcja zostanie wywo\u0142ana dopiero w run time co go niepotrzebnie obci\u0105\u017cy constexpr float PI { 3.14159 }; float circle_area(const float r){ return PI * r * r; } const area = circle_area(10.0); std::cout << area; \u2705 teraz ta funkcja zostanie wywo\u0142ana podczas kompilacji i run time jedyne co b\u0119dzie musia\u0142 zrobi\u0107 to wypisa\u0107 pole constexpr float PI { 3.14159 }; constexpr float circle_area(const float r){ return PI * r * r; } constexpr area = circle_area(10.0); std::cout << area; Materia\u0142y https://www.learncpp.com/cpp-tutorial/constexpr-functions/ 5. abstrakcja nie jest z\u0142a 6. Pisz kod Jak najpro\u015bciej sie da Pow\u00f3d Utrzymuj kod jak najprostszy, je\u017celi zaawansowane struktury danych nie s\u0105 niezb\u0119dne, to ich nie u\u017cywaj. Przyk\u0142ad std::string percentage_to_rounds(float percentage){ std::string result{}; for (int i = 0; i < 10; i++){ if (result/10.0f <= percentage) result += \"\ud83d\udd35\"; else result += \"\u26aa\"; } return result; } std::string percentage_to_rounds(float percentage) { if (percentage == 0) return \"\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.0 && percentage <= 0.1) return \"\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.1 && percentage <= 0.2) return \"\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.2 && percentage <= 0.3) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.3 && percentage <= 0.4) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.4 && percentage <= 0.5) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.5 && percentage <= 0.6) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.6 && percentage <= 0.7) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\" if (percentage > 0.7 && percentage <= 0.8) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\" if (percentage > 0.8 && percentage <= 0.9) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\" return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\" } Tak, to jest przyk\u0142ad z mema... Pisanie Kodu Feature U\u017cywamy Komentarz std::views \ud83d\udfe8 Mo\u017ce wprowadza\u0107 zamieszanie Makra \ud83d\udfe8 Nie jest type safe ale czasami mo\u017ce p constexpr \u2705 STL \ud83d\udfe8 Alternatyw\u0105 cz\u0119sto jest ETL koncepty \u2705 new \u274c malloc \u274c C Array \u274c Mamy std::array C Enum \u274c Mamy enum class U\u017cywaj STL / ETL Pow\u00f3d Nie warto marnowa\u0107 czasu na pisanie w\u0142asnych algorytm\u00f3w i kontener\u00f3w Przyk\u0142ad nazwa zosta\u0142a funkcji celowo wypikana. \u274c Algorytm dzia\u0142a poprawnie, ale nie wida\u0107 na pierwszy rzut oka co robi, trzeba przekaza\u0107 dwa argumenty, generalnie kongo. float ...(int* tab, size_t len){ float sum = 0; for(int i = 0; i < len; i++) sum += tab[i]; return sum / len; } \ud83d\udfe8 Jest ju\u017c type safe i ekspresywnie ze wzgl\u0119du na u\u017cycie std::span i std::accumulate ale mo\u017cna lepiej... float ...(std::span<int> tab){ return std::accumulate(tab.begin(), tab.end(), 0.0) / tab.size(); } \u2705 U\u017cywanie wersji algorytm\u00f3w z ::ranges ukrywa u\u017cycie iterator\u00f3w wi\u0119c mniej kodu + mniejsza szansa na b\u0142\u0105d. float ...(std::span<int> tab){ return std::ranges::accumulate(tab, 0.0) / tab.size(); } Do operacji bitowych zawsze std::byte std::byte u\u017cyjemy je\u017celi wczytujemy co\u015b z pami\u0119ci kt\u00f3re potem ma by\u0107 jako\u015b zinterpretowane std::byte jest type safe i dobrze oddaje intencje. Error handling Do tego b\u0119dziemy u\u017cywa\u0107 std::expected Funkcje Wska\u017aniki do pami\u0119ci dynamicznej Nie u\u017cywaj go\u0142ych wska\u017anik\u00f3w, s\u0105 bezpieczniejsze i lepsze rozwi\u0105zania prosto z C++ w <memory> mamy do dyspozycji std::unique_ptr std::shared_ptr std::weak_ptr Asercje w funkcjach Pow\u00f3d Ka\u017cda Funkcja powinna zawiera\u0107 asercj\u0119 dla przypadk\u00f3w kt\u00f3re nie powinny nigdy si\u0119 wydarzy\u0107. Prawda jest taka im wi\u0119cej check\u00f3w tym lepiej dla nas, przy debugowaniu jeste\u015bmy w stanie odrazu wykluczy\u0107 pewne przypadki, przy pisaniu nowych funkcjonalno\u015bci b\u0119da to dla nas pierwsze testy. W ten spos\u00f3b mo\u017cemy te\u017c sprawdzi\u0107 poprawno\u015b\u0107 danych lataj\u0105cych w programie. Przyk\u0142ad \u274c Je\u017celi zostanie przekazany nullptr to mo\u017ce by\u0107 nieciekawie... int sum(int * tab, size_t len) { int sum = 0; for (int i = 0; i < len; i++) sum += tab[i]; return sum; } \u2705 W ten spos\u00f3b upewnimy si\u0119 czy tab nie jest nullptr i czy nie mamy b\u0142\u0119du w data flow int sum(int * tab, size_t len) { assert(tab != nullptr); assert(len != 0); assert(len < 0); int sum = 0; for (int i = 0; i < len; i++) sum += tab[i]; return sum; } \u0179r\u00f3d\u0142a NASA pkt.5 D\u0142ugo\u015b\u0107 funkcji Funkcje nie powinny by\u0107 d\u0142u\u017csze ni\u017c 40 linijek. Nie wymagamy od programist\u00f3w pionowego monitora 29' do czytania kodu. Je\u017celi funkcja jest za d\u0142uga powiniene\u015b podzieli\u0107 j\u0105 na mniejsze funkcje [?] Trailing Return Type auto get_raw_data() -> void { ... } Zmienne U\u017cywanie auto Auto mo\u017ce w du\u017cym stopniu upro\u015bci\u0107 kod, ale w pewnych przypadkach jest to po prostu nie wskazane. Przypadki u\u017cycia - auto w for-range loop cpp for (auto num : numbers) Nazewnictwo Nazwy zmiennych powinny przedewszystkim informowa\u0107 o tym co jest w \u015brodku, u\u017cywaj deskryptywnych nazw Nie b\u00f3j si\u0119 d\u0142ugich nazw, wi\u0119kszo\u015b\u0107 z nas ma takie co\u015b jak TAB, wi\u0119c to czy zmienna ma 5 znak\u00f3w czy 15 nie robi r\u00f3\u017cnicy bo i tak u\u017cyjemy autocomplete. Rodzaj Case Zmienne globalne UPPER_SNAKE_CASE Makra UPPER_SNAKE_CASE constexpr UPPER_SNAKE_CASE Funkcje snake_case Metody snake_case zmienne snake_case Klasy PascalCase Namespace PascalCase Aliasy PascalCase Nazewnictwo for-range loop Jak wiadomo je\u017celi iterujemy przez pewn\u0105 kolekcje i interesuje nas tylko zawarto\u015b\u0107 tej kolekcji u\u017cyjemy for-range loop, co jest dobre, ale \u017ceby jeszcze lepiej to zrobi\u0107 mo\u017cemy nazywa\u0107 iterator zgodnie z tym co b\u0119dzie w nim przechowywane. \u274c Typowy fragment kodu w kt\u00f3rym bez szerszego kontekstu nie wiadomo o co chodzi float total_distance = 0.0f; for (auto x : vec){ total_distance += sqrt(x.x * x.x + x.y * x.y) } \u2705 Wiadomo przez co iterujemy i wiadomo co jest float total_distance = 0.0f for (auto point : points){ total_distance += sqrt(point.x * point.x + point.y * point.y) } [?] Skr\u00f3ty w nazewnictwie U\u017cywamy tylko skr\u00f3t\u00f3w kt\u00f3re znajduj\u0105 si\u0119 w s\u0142owniczku U\u017cywanie Namespace Nie u\u017cywamy emoji jako nazw Przyk\u0142ad \u274c class Kernel; Kernel \ud83e\udd5a; Przyk\u0142ad \u2705 class Kernel; Kernel kernel; Szablony Koncepty Koncepty zosta\u0142y wprowadzone w C++20 s\u0142u\u017c\u0105 one do polepszenia jako\u015bci b\u0142\u0119d\u00f3w generowanych przez templaty, z tego ka\u017cda klasa/funkcja u\u017cywaj\u0105ca szablonu maj\u0105ca pewne ograniczenia powinna by\u0107 ograniczona konceptem \u274c Jednak informacja 'const char*' and 'const char*' to binary 'operator+' nie jest taka czytelna template <typename T> T add(T a, T b) { return a + b; } add(\"PIT\", \"BULL\"); B\u0142\u0119dy error: invalid operands of types 'const char ' and 'const char ' to binary 'operator+' 5 | return a + b; \u2705 Dostaniemy czytelny b\u0142\u0105d i jeszcze IDE b\u0119dzie podkre\u015bla\u0142o b\u0142\u0105d template <typename T> concept Addable = requires(T a, T b) { { a + b } -> same_as<T>; }; template <Addable T> T add(T a, T b) { return a + b; } add(\"SUPER\", \"BLEDY!\"); B\u0142\u0119dy note: candidate: 'template requires Addable T add(T, T)' | T add(T a, T b) Materia\u0142y https://en.cppreference.com/w/cpp/language/constraints Formatowanie Forward Declaration Nawiasy w\u0105sate K&R Odst\u0119py 1 tabulacja - 4 spacje Struktura projektu U\u017cywamy plik\u00f3w .hpp i .cpp Komentarze Kod powinien by\u0107 pisany w taki spos\u00f3b \u017ceby komentarze by\u0142y zb\u0119dne. Wyj\u0105tek Czasmi oczywi\u015bcie nie jest to mo\u017cliwe. Nie zawsze da si\u0119 przekaza\u0107 intencje u\u017cywajac tylko kodu, szczeg\u00f3lnie je\u017celi jest to ekstremalnie zoptymalizowany fragment kodu lub implementacja jakiego\u015b interfejsu. Klasy Struct vs Class Pow\u00f3d Struct powinien s\u0142u\u017cy\u0107 tylko wy\u0142\u0105cznie jako DTO, jedyne metody jakie mo\u017ce mie\u0107 to akcesory do p\u00f3l i proste metody obliczaj\u0105ce swoje w\u0142asno\u015bci. Klasa z kolei jest opisem obiektu Przyk\u0142ad struct struct Vec2 { float x; float y; float length(){ return sqrt(x*x + y*y); } } class class BME280{ void read_raw_data(); void read_data(); } Inicjaizaca p\u00f3l Ka\u017cda Klasa ka\u017cde pole kt\u00f3re mo\u017ce powinna zaincjalizowa\u0107 u\u017cywaj\u0105c {} unikniemy w ten spos\u00f3b du\u017cej ilo\u015bci pisania kodu w konstruktorze, je\u017celi konstruktor przyjmuje warto\u015bci to powinny zosta\u0107 przypisane w liscie inicjalizacyjnej Funkcja inicjalizacyjna Pow\u00f3d Ka\u017cda klasa powinna funkcje init() w kt\u00f3rej zostan\u0105 wykonane wszysktie operacje ci\u0119\u017ckie i takie kt\u00f3re mog\u0105 wyrzuci\u0107 b\u0142\u0105d. Przyk\u0142ad \u274c Obs\u0142uga b\u0142\u0119d\u00f3w jest prawie niemo\u017cliwa, po utworzeniu instancji odrazu b\u0119dzie chcia\u0142a si\u0119 zaincjalizowa\u0107 class BME280 { BME280(){ if (read_id() != 0x80){ std::cout << \"BME280 connection failed\"; while(1); } } } \u2705 Mo\u017cna generycznie obs\u0142u\u017cy\u0107 b\u0142\u0105d, mo\u017cna powt\u00f3rzy\u0107 inicjalizacj\u0119 przy b\u0142\u0119dzie. class BME280 { BME280(){} std::epxected<bool,I2CErors> init(){ if (read_id() != 0x80) return I2CError::id_read; } } \u0179r\u00f3d\u0142a https://google.github.io/styleguide/cppguide.html#Doing_Work_in_Constructors Akcja pe\u0142na enkapsulacja i akcesory [?] U\u017cywanie this->... Pow\u00f3d Jak przekaza\u0107 informacj\u0119 o tym \u017ce zmienna jest polem klasy? rozwi\u0105za\u0144 jest kilka - u\u017cywanie `_` przed nazw\u0105 pola np. `_count` - `m` przed nazw\u0105 pola np. `m_count` - `this->` this->count U\u017cywaj private,protected i public Pow\u00f3d Definiuj dobrze interfejsy klas zgodnie z ich przeznaczeniem, je\u017celi u\u017cycie metody poza klas\u0105 nie jest wymagane oznacz j\u0105 jako private Przyk\u0142ad Obs\u0142uga gita Ka\u017cdy branch mergowany do mastera musi posiada\u0107: Stworzon\u0105 dokumentacj\u0119 nowych funkcjionalno\u015bci Zosta\u0107 zatwierdzonym przez 2 innych programist\u00f3w By\u0107 zgodnym ze stylem pisania kodu Tworzenie dokumentacji Dokumentacja powinna przedewszystkim istnie\u0107 i by\u0107 aktualna. Brak dokumentacji czy jej niezgodno\u015b\u0107 z rzeczywisto\u015bci\u0105 nie tylko powoduje spowolnienie prac ale przede wszystkim frustracje. A jak dobrze wiadomo jedyne osoby kt\u00f3re mog\u0105 pisa\u0107 dokumetancje to s\u0105 ludzie kt\u00f3rzy stworzyli pewny fragment kodu, z tego powodu te zasady maj\u0105ce na celu upro\u015bci\u0107 do minimum, u\u0142atwi\u0107 i unifikowa\u0107 tooling, spos\u00f3b i styl pisania dokumentacji. Doxygen Inne #pragma once Pow\u00f3d Ka\u017cdy plik .hpp MUSI mie\u0107 co\u015b \u017ceby przeciwdzia\u0142a\u0107 wielokrotnym do\u0142\u0105czeniom, w C++ s\u0105 2 sposoby na zrobienie tego u\u017cywaj\u0105c #define guarda i #pragma once , ten pierwszy jest dzia\u0142aj\u0105cy niezale\u017cnie od platformy, ale ma kilka problem\u00f3w: Du\u017co pisania Mo\u017cliwa podw\u00f3jna definicja makra \u017beby gwarantowa\u0107 unikalno\u015b\u0107 trzeba by u\u017cywa\u0107 pe\u0142nej \u015bcie\u017cki do pliku Trzeba r\u0119cznie uwzgl\u0119dni\u0107 zmiane makra po zmianie nazwy pliku #pragma once to wszystko rozwi\u0105zuje, jedyne problemy z #pragma once to \u017ce nie jest oficjaln\u0105 cz\u0119\u015bci\u0105 standardu wi\u0119c nie musi dzia\u0142a\u0107 wsz\u0119dzie, ale u nas akurat dzia\u0142a :3 Przyk\u0142ad \u274c #ifndef DRIVERS_UART_LL_HPP_ #define DRIVERS_UART_LL_HPP_ ... #endif // FILE_HPP \u2705 #pragma once ... Testowanie Testy jednostkowe Hardware in the loop Data injection Design Paterny Maszyna stanu Singleton Factory Decorator Plan dzia\u0142ania 1.","title":"Home"},{"location":"#wielka-ksiega-przewinien-programistow-osadzonych","text":"NASA Google ISO C++ SAT","title":"Wielka ksi\u0119ga przewinie\u0144 programist\u00f3w osadzonych"},{"location":"#wstep","text":"Jak wiadomo, dokumentacji nikt nie b\u0119dzie czyta\u0142 dok\u0142adnie, s\u0142owo w s\u0142owo. Wi\u0119c prosz\u0119 si\u0119 nie zdziwi\u0107 jak pojawi\u0105 si\u0119 tutaj jajka wielkanocno \u015bwi\u0105teczne, a forma nie b\u0119dzie w pe\u0142ni oficjalna. Ka\u017cdy punkt b\u0119dzie wygl\u0105da\u0142 na zasadzie Rozwi\u0105zanie -> Problemy tego rozwi\u0105zania -> Lepsze rozwi\u0105zanie + potencjalne wyj\u0105tki B\u0119dzie u\u017cywany C++20, skoro robimy co\u015b mega, to b\u0119dzie nowocze\u015bnie.","title":"Wst\u0119p"},{"location":"#zaozenia","text":"Projekt tworzenia studenckiego satelity, nie jest projektem drogiej todo listy. Programi\u015bci, przychodz\u0105, odchodz\u0105, stale... Programi\u015bci w projekcie b\u0119da si\u0119 przewija\u0107, b\u0119da z r\u00f3\u017cnym do\u015bwiadczeniem, z r\u00f3\u017cn\u0105 wiedz\u0105. To jest pow\u00f3d dla kt\u00f3rego kod powinien by\u0107 jak najprostszy, to znaczy, bez fiku\u015bnych twor\u00f3w np std::views , z du\u017c\u0105 ilo\u015bci\u0105 dokumentacji. W takim wypadku wdro\u017cenie nowej osoby do projektu powinno te\u017c przebiega\u0107 szybko. Programi\u015bci b\u0119da przychodzi\u0107 z innych j\u0119zyk\u00f3w.","title":"Za\u0142o\u017cenia"},{"location":"#todo","text":"proces wdra\u017cania nowych ludzi do projektu","title":"todo"},{"location":"#setup-projektu","text":"","title":"Setup Projektu"},{"location":"#flagi-kompilatora","text":"Kompilator powinen krzycze\u0107 na wszystkie erorry i warningi wszystko na czerwono taka litania -Wall -Wextra -Wpedantic -Werror -Wconversion -Wshadow -Wstrict-overflow=5 -Wfloat-equal -Wformat=2 \\ -Wundef -Wpointer-arith -Wcast-qual -Wcast-align=strict -Wstrict-prototypes -Wwrite-strings -Wstack-protector \\ -Wswitch-enum -Wswitch-default -Wunreachable-code -Wduplicated-cond -Wduplicated-branches -Wlogical-op \\ -Wnull-dereference -Wuseless-cast -Wdouble-promotion -Walloca -Walloc-zero -Wvla -Wformat-signedness \\ -Wstrict-aliasing=3 -Wdisabled-optimization -Wunsafe-loop-optimizations -Wvector-operation-performance \\ -Wpessimizing-move -Wredundant-move -Wmisleading-indentation -Wvolatile-register-var -Wdate-time","title":"Flagi kompilatora"},{"location":"#todo_1","text":"jak wszystko b\u0119dzie gotowe to jaki\u015b filmik co\u015b ten powstanie","title":"todo"},{"location":"#filozofia-pisania-kodu","text":"","title":"Filozofia pisania kodu"},{"location":"#wydajnosc","text":"Wydajno\u015b\u0107 nie jest najwa\u017cniejsza, ale nie jest pomijalna. Wydajno\u015b\u0107 kodu bezpo\u015brednio przek\u0142ada si\u0119 m.in na zu\u017cycie energii przez satelit\u0119.","title":"Wydajno\u015b\u0107"},{"location":"#piszemy-kod-zgodny-ze-standardami-iso-wolnym-od-ub-i-zaleznym-od-kompilatora","text":"","title":"Piszemy kod zgodny ze standardami ISO, wolnym od UB i zale\u017cnym od kompilatora"},{"location":"#1-czytanie-kodu","text":"Kod b\u0119dzie czytany wi\u0119cej razy, ni\u017c b\u0119dzie pisany, dlatego czytelno\u015b\u0107 powinna by\u0107 zawsze priorytetem. Dobrze napisany kod to taki, kt\u00f3ry mo\u017cna \u0142atwo zrozumie\u0107 bez konieczno\u015bci g\u0142\u0119bokiej analizy. Przejrzysty kod u\u0142atwia jego utrzymanie, modyfikacj\u0119 oraz wsp\u00f3\u0142prac\u0119 w zespole.","title":"1. Czytanie Kodu."},{"location":"#2-kod-ma-wyrazac-intencje","text":"Pierwszym punktem \u017ceby uczyni\u0107 kod czytelniejszym, programista ma przekazywa\u0107 swoje intencje w kodzie, przez nazewnictwo, dob\u00f3r algorytm\u00f3w i struktur danych. Spos\u00f3b pisania kodu powinien by\u0107 jak najbardziej przewidywalny dla innych. \u274cFunkcja c nie m\u00f3wi nic o swojej intencji \u2013 nazwa jest nieczytelna. Parametry a i b nic nie wyja\u015bniaj\u0105. int A(int a, int b) { return a * b; } \u2705Funkcja ma teraz nazw\u0119 calculateArea, co jasno okre\u015bla jej cel. Parametry width i height m\u00f3wi\u0105, do czego s\u0142u\u017c\u0105. int calculateArea(int width, int height) { return width * height; }","title":"2. Kod ma wyra\u017ca\u0107 intencje."},{"location":"#3-type-safety-first","text":"Zgodno\u015b\u0107 typ\u00f3w jest jednym z najpot\u0119\u017cniejszych narz\u0119dzi walki z robakami (en. bug) w kodzie \u274c void print_arr(void* arr, size_t len){ for(int i = 0; i < len; i++) std::cout << arr[i]; } \u2705 ```cpp template <typename T> void print_arr(std::span<T> arr){ for(const auto& item : arr) std::cout << item; }","title":"3. Type safety first"},{"location":"#typy-do-reprezentacji-jednostek-si","text":"","title":"[?] Typy do reprezentacji jednostek SI"},{"location":"#4-wybieraj-wykonanie-w-compile-time-zamiast-run-time","text":"Pow\u00f3d Je\u017celi jeste\u015b w stanie zrobi\u0107 co\u015b w compile to tym zwi\u0119kszysz performance kodu. Przyk\u0142ad \u274c Funkcja zostanie wywo\u0142ana dopiero w run time co go niepotrzebnie obci\u0105\u017cy constexpr float PI { 3.14159 }; float circle_area(const float r){ return PI * r * r; } const area = circle_area(10.0); std::cout << area; \u2705 teraz ta funkcja zostanie wywo\u0142ana podczas kompilacji i run time jedyne co b\u0119dzie musia\u0142 zrobi\u0107 to wypisa\u0107 pole constexpr float PI { 3.14159 }; constexpr float circle_area(const float r){ return PI * r * r; } constexpr area = circle_area(10.0); std::cout << area; Materia\u0142y https://www.learncpp.com/cpp-tutorial/constexpr-functions/","title":"4. Wybieraj wykonanie w compile time zamiast run time"},{"location":"#5-abstrakcja-nie-jest-za","text":"","title":"5. abstrakcja nie jest z\u0142a"},{"location":"#6-pisz-kod-jak-najprosciej-sie-da","text":"Pow\u00f3d Utrzymuj kod jak najprostszy, je\u017celi zaawansowane struktury danych nie s\u0105 niezb\u0119dne, to ich nie u\u017cywaj. Przyk\u0142ad std::string percentage_to_rounds(float percentage){ std::string result{}; for (int i = 0; i < 10; i++){ if (result/10.0f <= percentage) result += \"\ud83d\udd35\"; else result += \"\u26aa\"; } return result; } std::string percentage_to_rounds(float percentage) { if (percentage == 0) return \"\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.0 && percentage <= 0.1) return \"\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.1 && percentage <= 0.2) return \"\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.2 && percentage <= 0.3) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.3 && percentage <= 0.4) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.4 && percentage <= 0.5) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.5 && percentage <= 0.6) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\u26aa\" if (percentage > 0.6 && percentage <= 0.7) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\u26aa\" if (percentage > 0.7 && percentage <= 0.8) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\u26aa\" if (percentage > 0.8 && percentage <= 0.9) return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\u26aa\" return \"\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\ud83d\udd35\" } Tak, to jest przyk\u0142ad z mema...","title":"6. Pisz kod Jak najpro\u015bciej sie da"},{"location":"#pisanie-kodu","text":"Feature U\u017cywamy Komentarz std::views \ud83d\udfe8 Mo\u017ce wprowadza\u0107 zamieszanie Makra \ud83d\udfe8 Nie jest type safe ale czasami mo\u017ce p constexpr \u2705 STL \ud83d\udfe8 Alternatyw\u0105 cz\u0119sto jest ETL koncepty \u2705 new \u274c malloc \u274c C Array \u274c Mamy std::array C Enum \u274c Mamy enum class","title":"Pisanie Kodu"},{"location":"#uzywaj-stl-etl","text":"Pow\u00f3d Nie warto marnowa\u0107 czasu na pisanie w\u0142asnych algorytm\u00f3w i kontener\u00f3w Przyk\u0142ad nazwa zosta\u0142a funkcji celowo wypikana. \u274c Algorytm dzia\u0142a poprawnie, ale nie wida\u0107 na pierwszy rzut oka co robi, trzeba przekaza\u0107 dwa argumenty, generalnie kongo. float ...(int* tab, size_t len){ float sum = 0; for(int i = 0; i < len; i++) sum += tab[i]; return sum / len; } \ud83d\udfe8 Jest ju\u017c type safe i ekspresywnie ze wzgl\u0119du na u\u017cycie std::span i std::accumulate ale mo\u017cna lepiej... float ...(std::span<int> tab){ return std::accumulate(tab.begin(), tab.end(), 0.0) / tab.size(); } \u2705 U\u017cywanie wersji algorytm\u00f3w z ::ranges ukrywa u\u017cycie iterator\u00f3w wi\u0119c mniej kodu + mniejsza szansa na b\u0142\u0105d. float ...(std::span<int> tab){ return std::ranges::accumulate(tab, 0.0) / tab.size(); }","title":"U\u017cywaj STL / ETL"},{"location":"#do-operacji-bitowych-zawsze-stdbyte","text":"std::byte u\u017cyjemy je\u017celi wczytujemy co\u015b z pami\u0119ci kt\u00f3re potem ma by\u0107 jako\u015b zinterpretowane std::byte jest type safe i dobrze oddaje intencje.","title":"Do operacji bitowych zawsze std::byte"},{"location":"#error-handling","text":"Do tego b\u0119dziemy u\u017cywa\u0107 std::expected","title":"Error handling"},{"location":"#funkcje","text":"","title":"Funkcje"},{"location":"#wskazniki-do-pamieci-dynamicznej","text":"Nie u\u017cywaj go\u0142ych wska\u017anik\u00f3w, s\u0105 bezpieczniejsze i lepsze rozwi\u0105zania prosto z C++ w <memory> mamy do dyspozycji std::unique_ptr std::shared_ptr std::weak_ptr","title":"Wska\u017aniki do pami\u0119ci dynamicznej"},{"location":"#asercje-w-funkcjach","text":"Pow\u00f3d Ka\u017cda Funkcja powinna zawiera\u0107 asercj\u0119 dla przypadk\u00f3w kt\u00f3re nie powinny nigdy si\u0119 wydarzy\u0107. Prawda jest taka im wi\u0119cej check\u00f3w tym lepiej dla nas, przy debugowaniu jeste\u015bmy w stanie odrazu wykluczy\u0107 pewne przypadki, przy pisaniu nowych funkcjonalno\u015bci b\u0119da to dla nas pierwsze testy. W ten spos\u00f3b mo\u017cemy te\u017c sprawdzi\u0107 poprawno\u015b\u0107 danych lataj\u0105cych w programie. Przyk\u0142ad \u274c Je\u017celi zostanie przekazany nullptr to mo\u017ce by\u0107 nieciekawie... int sum(int * tab, size_t len) { int sum = 0; for (int i = 0; i < len; i++) sum += tab[i]; return sum; } \u2705 W ten spos\u00f3b upewnimy si\u0119 czy tab nie jest nullptr i czy nie mamy b\u0142\u0119du w data flow int sum(int * tab, size_t len) { assert(tab != nullptr); assert(len != 0); assert(len < 0); int sum = 0; for (int i = 0; i < len; i++) sum += tab[i]; return sum; } \u0179r\u00f3d\u0142a NASA pkt.5","title":"Asercje w funkcjach"},{"location":"#dugosc-funkcji","text":"Funkcje nie powinny by\u0107 d\u0142u\u017csze ni\u017c 40 linijek. Nie wymagamy od programist\u00f3w pionowego monitora 29' do czytania kodu. Je\u017celi funkcja jest za d\u0142uga powiniene\u015b podzieli\u0107 j\u0105 na mniejsze funkcje","title":"D\u0142ugo\u015b\u0107 funkcji"},{"location":"#trailing-return-type","text":"auto get_raw_data() -> void { ... }","title":"[?] Trailing Return Type"},{"location":"#zmienne","text":"","title":"Zmienne"},{"location":"#uzywanie-auto","text":"Auto mo\u017ce w du\u017cym stopniu upro\u015bci\u0107 kod, ale w pewnych przypadkach jest to po prostu nie wskazane. Przypadki u\u017cycia - auto w for-range loop cpp for (auto num : numbers)","title":"U\u017cywanie auto"},{"location":"#nazewnictwo","text":"Nazwy zmiennych powinny przedewszystkim informowa\u0107 o tym co jest w \u015brodku, u\u017cywaj deskryptywnych nazw Nie b\u00f3j si\u0119 d\u0142ugich nazw, wi\u0119kszo\u015b\u0107 z nas ma takie co\u015b jak TAB, wi\u0119c to czy zmienna ma 5 znak\u00f3w czy 15 nie robi r\u00f3\u017cnicy bo i tak u\u017cyjemy autocomplete. Rodzaj Case Zmienne globalne UPPER_SNAKE_CASE Makra UPPER_SNAKE_CASE constexpr UPPER_SNAKE_CASE Funkcje snake_case Metody snake_case zmienne snake_case Klasy PascalCase Namespace PascalCase Aliasy PascalCase","title":"Nazewnictwo"},{"location":"#nazewnictwo-for-range-loop","text":"Jak wiadomo je\u017celi iterujemy przez pewn\u0105 kolekcje i interesuje nas tylko zawarto\u015b\u0107 tej kolekcji u\u017cyjemy for-range loop, co jest dobre, ale \u017ceby jeszcze lepiej to zrobi\u0107 mo\u017cemy nazywa\u0107 iterator zgodnie z tym co b\u0119dzie w nim przechowywane. \u274c Typowy fragment kodu w kt\u00f3rym bez szerszego kontekstu nie wiadomo o co chodzi float total_distance = 0.0f; for (auto x : vec){ total_distance += sqrt(x.x * x.x + x.y * x.y) } \u2705 Wiadomo przez co iterujemy i wiadomo co jest float total_distance = 0.0f for (auto point : points){ total_distance += sqrt(point.x * point.x + point.y * point.y) }","title":"Nazewnictwo for-range loop"},{"location":"#skroty-w-nazewnictwie","text":"U\u017cywamy tylko skr\u00f3t\u00f3w kt\u00f3re znajduj\u0105 si\u0119 w s\u0142owniczku","title":"[?] Skr\u00f3ty w nazewnictwie"},{"location":"#uzywanie-namespace","text":"","title":"U\u017cywanie Namespace"},{"location":"#nie-uzywamy-emoji-jako-nazw","text":"Przyk\u0142ad \u274c class Kernel; Kernel \ud83e\udd5a; Przyk\u0142ad \u2705 class Kernel; Kernel kernel;","title":"Nie u\u017cywamy emoji jako nazw"},{"location":"#szablony","text":"","title":"Szablony"},{"location":"#koncepty","text":"Koncepty zosta\u0142y wprowadzone w C++20 s\u0142u\u017c\u0105 one do polepszenia jako\u015bci b\u0142\u0119d\u00f3w generowanych przez templaty, z tego ka\u017cda klasa/funkcja u\u017cywaj\u0105ca szablonu maj\u0105ca pewne ograniczenia powinna by\u0107 ograniczona konceptem \u274c Jednak informacja 'const char*' and 'const char*' to binary 'operator+' nie jest taka czytelna template <typename T> T add(T a, T b) { return a + b; } add(\"PIT\", \"BULL\"); B\u0142\u0119dy error: invalid operands of types 'const char ' and 'const char ' to binary 'operator+' 5 | return a + b; \u2705 Dostaniemy czytelny b\u0142\u0105d i jeszcze IDE b\u0119dzie podkre\u015bla\u0142o b\u0142\u0105d template <typename T> concept Addable = requires(T a, T b) { { a + b } -> same_as<T>; }; template <Addable T> T add(T a, T b) { return a + b; } add(\"SUPER\", \"BLEDY!\"); B\u0142\u0119dy note: candidate: 'template requires Addable T add(T, T)' | T add(T a, T b) Materia\u0142y https://en.cppreference.com/w/cpp/language/constraints","title":"Koncepty"},{"location":"#formatowanie","text":"","title":"Formatowanie"},{"location":"#forward-declaration","text":"","title":"Forward Declaration"},{"location":"#nawiasy-wasate","text":"K&R","title":"Nawiasy w\u0105sate"},{"location":"#odstepy","text":"1 tabulacja - 4 spacje","title":"Odst\u0119py"},{"location":"#struktura-projektu","text":"U\u017cywamy plik\u00f3w .hpp i .cpp","title":"Struktura projektu"},{"location":"#komentarze","text":"Kod powinien by\u0107 pisany w taki spos\u00f3b \u017ceby komentarze by\u0142y zb\u0119dne. Wyj\u0105tek Czasmi oczywi\u015bcie nie jest to mo\u017cliwe. Nie zawsze da si\u0119 przekaza\u0107 intencje u\u017cywajac tylko kodu, szczeg\u00f3lnie je\u017celi jest to ekstremalnie zoptymalizowany fragment kodu lub implementacja jakiego\u015b interfejsu.","title":"Komentarze"},{"location":"#klasy","text":"","title":"Klasy"},{"location":"#struct-vs-class","text":"Pow\u00f3d Struct powinien s\u0142u\u017cy\u0107 tylko wy\u0142\u0105cznie jako DTO, jedyne metody jakie mo\u017ce mie\u0107 to akcesory do p\u00f3l i proste metody obliczaj\u0105ce swoje w\u0142asno\u015bci. Klasa z kolei jest opisem obiektu Przyk\u0142ad struct struct Vec2 { float x; float y; float length(){ return sqrt(x*x + y*y); } } class class BME280{ void read_raw_data(); void read_data(); }","title":"Struct vs Class"},{"location":"#inicjaizaca-pol","text":"Ka\u017cda Klasa ka\u017cde pole kt\u00f3re mo\u017ce powinna zaincjalizowa\u0107 u\u017cywaj\u0105c {} unikniemy w ten spos\u00f3b du\u017cej ilo\u015bci pisania kodu w konstruktorze, je\u017celi konstruktor przyjmuje warto\u015bci to powinny zosta\u0107 przypisane w liscie inicjalizacyjnej","title":"Inicjaizaca p\u00f3l"},{"location":"#funkcja-inicjalizacyjna","text":"Pow\u00f3d Ka\u017cda klasa powinna funkcje init() w kt\u00f3rej zostan\u0105 wykonane wszysktie operacje ci\u0119\u017ckie i takie kt\u00f3re mog\u0105 wyrzuci\u0107 b\u0142\u0105d. Przyk\u0142ad \u274c Obs\u0142uga b\u0142\u0119d\u00f3w jest prawie niemo\u017cliwa, po utworzeniu instancji odrazu b\u0119dzie chcia\u0142a si\u0119 zaincjalizowa\u0107 class BME280 { BME280(){ if (read_id() != 0x80){ std::cout << \"BME280 connection failed\"; while(1); } } } \u2705 Mo\u017cna generycznie obs\u0142u\u017cy\u0107 b\u0142\u0105d, mo\u017cna powt\u00f3rzy\u0107 inicjalizacj\u0119 przy b\u0142\u0119dzie. class BME280 { BME280(){} std::epxected<bool,I2CErors> init(){ if (read_id() != 0x80) return I2CError::id_read; } } \u0179r\u00f3d\u0142a https://google.github.io/styleguide/cppguide.html#Doing_Work_in_Constructors","title":"Funkcja inicjalizacyjna"},{"location":"#akcja-pena-enkapsulacja-i-akcesory","text":"","title":"Akcja pe\u0142na enkapsulacja i akcesory"},{"location":"#uzywanie-this-","text":"Pow\u00f3d Jak przekaza\u0107 informacj\u0119 o tym \u017ce zmienna jest polem klasy? rozwi\u0105za\u0144 jest kilka - u\u017cywanie `_` przed nazw\u0105 pola np. `_count` - `m` przed nazw\u0105 pola np. `m_count` - `this->` this->count","title":"[?] U\u017cywanie this-&gt;..."},{"location":"#uzywaj-privateprotected-i-public","text":"Pow\u00f3d Definiuj dobrze interfejsy klas zgodnie z ich przeznaczeniem, je\u017celi u\u017cycie metody poza klas\u0105 nie jest wymagane oznacz j\u0105 jako private Przyk\u0142ad","title":"U\u017cywaj private,protected i public"},{"location":"#obsuga-gita","text":"Ka\u017cdy branch mergowany do mastera musi posiada\u0107: Stworzon\u0105 dokumentacj\u0119 nowych funkcjionalno\u015bci Zosta\u0107 zatwierdzonym przez 2 innych programist\u00f3w By\u0107 zgodnym ze stylem pisania kodu","title":"Obs\u0142uga gita"},{"location":"#tworzenie-dokumentacji","text":"Dokumentacja powinna przedewszystkim istnie\u0107 i by\u0107 aktualna. Brak dokumentacji czy jej niezgodno\u015b\u0107 z rzeczywisto\u015bci\u0105 nie tylko powoduje spowolnienie prac ale przede wszystkim frustracje. A jak dobrze wiadomo jedyne osoby kt\u00f3re mog\u0105 pisa\u0107 dokumetancje to s\u0105 ludzie kt\u00f3rzy stworzyli pewny fragment kodu, z tego powodu te zasady maj\u0105ce na celu upro\u015bci\u0107 do minimum, u\u0142atwi\u0107 i unifikowa\u0107 tooling, spos\u00f3b i styl pisania dokumentacji. Doxygen","title":"Tworzenie dokumentacji"},{"location":"#inne","text":"","title":"Inne"},{"location":"#pragma-once","text":"Pow\u00f3d Ka\u017cdy plik .hpp MUSI mie\u0107 co\u015b \u017ceby przeciwdzia\u0142a\u0107 wielokrotnym do\u0142\u0105czeniom, w C++ s\u0105 2 sposoby na zrobienie tego u\u017cywaj\u0105c #define guarda i #pragma once , ten pierwszy jest dzia\u0142aj\u0105cy niezale\u017cnie od platformy, ale ma kilka problem\u00f3w: Du\u017co pisania Mo\u017cliwa podw\u00f3jna definicja makra \u017beby gwarantowa\u0107 unikalno\u015b\u0107 trzeba by u\u017cywa\u0107 pe\u0142nej \u015bcie\u017cki do pliku Trzeba r\u0119cznie uwzgl\u0119dni\u0107 zmiane makra po zmianie nazwy pliku #pragma once to wszystko rozwi\u0105zuje, jedyne problemy z #pragma once to \u017ce nie jest oficjaln\u0105 cz\u0119\u015bci\u0105 standardu wi\u0119c nie musi dzia\u0142a\u0107 wsz\u0119dzie, ale u nas akurat dzia\u0142a :3 Przyk\u0142ad \u274c #ifndef DRIVERS_UART_LL_HPP_ #define DRIVERS_UART_LL_HPP_ ... #endif // FILE_HPP \u2705 #pragma once ...","title":"#pragma once"},{"location":"#testowanie","text":"","title":"Testowanie"},{"location":"#testy-jednostkowe","text":"","title":"Testy jednostkowe"},{"location":"#hardware-in-the-loop","text":"","title":"Hardware in the loop"},{"location":"#data-injection","text":"","title":"Data injection"},{"location":"#design-paterny","text":"","title":"Design Paterny"},{"location":"#maszyna-stanu","text":"","title":"Maszyna stanu"},{"location":"#singleton","text":"","title":"Singleton"},{"location":"#factory","text":"","title":"Factory"},{"location":"#decorator","text":"","title":"Decorator"},{"location":"#plan-dziaania","text":"1.","title":"Plan dzia\u0142ania"},{"location":"sex/","text":"hehe","title":"Sex"}]}